"""
Comprehensive EventHub Monitoring Function
Azure Function that performs comprehensive monitoring of EventHub namespace
with detailed consumer group lag analysis and structured logging
"""

import logging
import azure.functions as func
from datetime import datetime
import time
import sys
import os

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

# Import centralized logging config (auto-configures on import)
from utils.logging_config import configure_logging

from utils.comprehensive_monitor import (
    ComprehensiveEventHubMonitor,
    ComprehensiveMonitorLogger
)


def get_namespace_configurations():
    """
    Get EventHub namespace configurations from environment variables.
    
    Supports two configuration patterns:
    1. Multiple namespaces (recommended):
       - EVENTHUB_NAMESPACES: comma-separated list of namespace names
       - For each namespace 'name', expects:
         - EVENTHUB_CONNECTION_STRING_<NAME>: connection string
         - RESOURCE_GROUP_<NAME> (optional): resource group
         - SUBSCRIPTION_ID_<NAME> (optional): subscription ID  
         - STORAGE_CONNECTION_STRING_<NAME> (optional): storage connection
    
    2. Single namespace (backward compatibility):
       - EventHubConnectionString: connection string
       - ResourceGroup (optional): resource group
       - SubscriptionId (optional): subscription ID
       - StorageConnectionString (optional): storage connection
    
    Returns:
        List of namespace configuration dictionaries
    """
    configs = []
    
    # Check for multiple namespaces configuration
    namespaces_env = os.environ.get("EVENTHUB_NAMESPACES")
    if namespaces_env:
        namespace_names = [name.strip() for name in namespaces_env.split(",")]
        
        for namespace_name in namespace_names:
            # Convert namespace name to uppercase for environment variable lookup
            env_suffix = namespace_name.upper().replace("-", "_")
            
            connection_string = os.environ.get(f"EVENTHUB_CONNECTION_STRING_{env_suffix}")
            if connection_string:
                config = {
                    'namespace': namespace_name,
                    'connection_string': connection_string,
                    'resource_group': os.environ.get(f"RESOURCE_GROUP_{env_suffix}"),
                    'subscription_id': os.environ.get(f"SUBSCRIPTION_ID_{env_suffix}"),
                    'storage_connection_string': os.environ.get(f"STORAGE_CONNECTION_STRING_{env_suffix}")
                }
                configs.append(config)
            else:
                logger = logging.getLogger("ComprehensiveEventHubMonitor")
                logger.error(f"‚ùå Missing connection string for namespace '{namespace_name}'. "
                           f"Expected environment variable: EVENTHUB_CONNECTION_STRING_{env_suffix}")
    
    # Fallback to single namespace configuration for backward compatibility
    if not configs:
        connection_string = os.environ.get("EventHubConnectionString")
        if connection_string:
            # Extract namespace from connection string for display
            namespace_name = "default"
            if "Endpoint=sb://" in connection_string:
                try:
                    namespace_name = connection_string.split("Endpoint=sb://")[1].split(".")[0]
                except (IndexError, AttributeError):
                    pass
            
            config = {
                'namespace': namespace_name,
                'connection_string': connection_string,
                'resource_group': os.environ.get("ResourceGroup"),
                'subscription_id': os.environ.get("SubscriptionId"),
                'storage_connection_string': os.environ.get("StorageConnectionString")
            }
            configs.append(config)
    
    return configs


def log_final_summary(logger: logging.Logger, namespace_results: list, total_processing_time: float,
                     total_eventhubs: int, total_partitions: int, total_consumer_groups: int):
    """Log final summary across all monitored namespaces"""
    
    logger.info(f"\n{'='*80}")
    logger.info("üèÅ FINAL MONITORING SUMMARY")
    logger.info(f"{'='*80}")
    
    successful_namespaces = [r for r in namespace_results if r['status'] == 'success']
    failed_namespaces = [r for r in namespace_results if r['status'] == 'error']
    
    logger.info(f"üéØ Total Namespaces Monitored: {len(namespace_results)}")
    logger.info(f"‚úÖ Successful: {len(successful_namespaces)}")
    logger.info(f"‚ùå Failed: {len(failed_namespaces)}")
    logger.info(f"‚è±Ô∏è  Total Processing Time: {total_processing_time:.2f} seconds")
    
    if successful_namespaces:
        logger.info(f"üìä Aggregate Metrics:")
        logger.info(f"   üì° Total EventHubs: {total_eventhubs}")
        logger.info(f"   üì¶ Total Partitions: {total_partitions}")
        logger.info(f"   üë• Total Consumer Groups: {total_consumer_groups}")
        
        # Calculate overall health across all namespaces
        all_active_cgs = 0
        all_total_cgs = 0
        
        for result in successful_namespaces:
            metrics = result['metrics']
            all_total_cgs += metrics.total_consumer_groups
            all_active_cgs += sum(eh.active_consumer_groups for eh in metrics.eventhubs)
        
        if all_total_cgs > 0:
            overall_activity = (all_active_cgs / all_total_cgs) * 100
            health_status = get_health_status(overall_activity)
            logger.info(f"üè• Overall Health: {health_status}")
            logger.info(f"   {all_active_cgs}/{all_total_cgs} consumer groups active across all namespaces")
    
    # Log individual namespace results
    logger.info(f"\nüìã Per-Namespace Results:")
    for result in namespace_results:
        namespace = result['namespace']
        processing_time = result['processing_time']
        
        if result['status'] == 'success':
            metrics = result['metrics']
            logger.info(f"   ‚úÖ {namespace}: {metrics.total_eventhubs} EventHubs, "
                       f"{metrics.total_consumer_groups} consumer groups "
                       f"({processing_time:.2f}s)")
        else:
            logger.info(f"   ‚ùå {namespace}: FAILED - {result['error']} ({processing_time:.2f}s)")
    
    # Log structured summary for monitoring systems
    summary_data = {
        "eventType": "MultiNamespaceMonitoringSummary",
        "timestamp": datetime.utcnow().isoformat(),
        "totalProcessingTimeSeconds": total_processing_time,
        "namespacesMonitored": len(namespace_results),
        "namespacesSuccessful": len(successful_namespaces),
        "namespacesFailed": len(failed_namespaces),
        "aggregateMetrics": {
            "totalEventHubs": total_eventhubs,
            "totalPartitions": total_partitions,
            "totalConsumerGroups": total_consumer_groups
        },
        "namespaceResults": [
            {
                "namespace": r['namespace'],
                "status": r['status'],
                "processingTime": r['processing_time'],
                "eventhubs": r['metrics'].total_eventhubs if r['status'] == 'success' else 0,
                "consumerGroups": r['metrics'].total_consumer_groups if r['status'] == 'success' else 0
            } for r in namespace_results
        ]
    }
    
    import json
    logger.info(f"Multi-Namespace Monitoring Summary: {json.dumps(summary_data)}")
    
    if failed_namespaces:
        logger.warning(f"‚ö†Ô∏è  {len(failed_namespaces)} namespace(s) failed monitoring - check logs for details")


def main(timer: func.TimerRequest) -> None:
    """
    Timer-triggered function for comprehensive EventHub monitoring
    
    Runs every 5 minutes to monitor:
    - All configured EventHub namespaces
    - All EventHubs in each namespace
    - All partitions for each EventHub
    - All consumer groups for each EventHub  
    - Detailed lag metrics for each consumer group/partition
    - Rich structured logging with data classes
    """
    logger = logging.getLogger("ComprehensiveEventHubMonitor")
    
    # Check if timer is past due
    if timer.past_due:
        logger.info('‚è∞ The timer is past due!')
    
    logger.info("üöÄ Starting comprehensive EventHub namespace monitoring...")
    start_time = time.time()
    
    # Get namespace configurations
    namespace_configs = get_namespace_configurations()
    
    if not namespace_configs:
        logger.error("‚ùå No EventHub namespace configurations found. Please configure environment variables.")
        return
    
    logger.info(f"üîß Found {len(namespace_configs)} namespace(s) to monitor:")
    for config in namespace_configs:
        logger.info(f"  üì° {config['namespace']} (Resource Group: {config['resource_group'] or 'Not provided'})")
    
    total_processing_time = 0
    total_eventhubs = 0
    total_partitions = 0  
    total_consumer_groups = 0
    namespace_results = []
    
    # Monitor each namespace
    for config in namespace_configs:
        namespace_name = config['namespace']
        logger.info(f"\n{'='*60}")
        logger.info(f"üéØ Starting monitoring for namespace: {namespace_name}")
        logger.info(f"{'='*60}")
        
        namespace_start_time = time.time()
        
        try:
            # Initialize comprehensive monitor for this namespace
            monitor = ComprehensiveEventHubMonitor(
                connection_string=config['connection_string'],
                subscription_id=config['subscription_id'],
                resource_group=config['resource_group'],
                storage_connection_string=config['storage_connection_string'],
                max_workers=8  # Parallel processing for better performance
            )
            
            # Initialize enhanced logger
            monitor_logger = ComprehensiveMonitorLogger(logger)
            
            logger.info(f"üì° Monitoring namespace: {monitor.namespace}")
            
            # Perform comprehensive monitoring
            namespace_metrics = monitor.monitor_namespace()
            
            namespace_processing_time = time.time() - namespace_start_time
            total_processing_time += namespace_processing_time
            
            # Accumulate totals
            total_eventhubs += namespace_metrics.total_eventhubs
            total_partitions += namespace_metrics.total_partitions
            total_consumer_groups += namespace_metrics.total_consumer_groups
            
            # Store results for final summary
            namespace_results.append({
                'namespace': namespace_name,
                'metrics': namespace_metrics,
                'processing_time': namespace_processing_time,
                'status': 'success'
            })
            
            # Log comprehensive results using structured logging
            log_monitoring_results(logger, monitor_logger, namespace_metrics, namespace_processing_time)
            
            # Clean up resources
            monitor.close_all_clients()
            
            logger.info(f"‚úÖ Namespace '{namespace_name}' monitoring completed in {namespace_processing_time:.2f} seconds")
            logger.info(f"üìä Namespace Summary: {namespace_metrics.total_eventhubs} EventHubs, "
                       f"{namespace_metrics.total_partitions} partitions, "
                       f"{namespace_metrics.total_consumer_groups} consumer groups")
            
        except Exception as e:
            namespace_processing_time = time.time() - namespace_start_time
            total_processing_time += namespace_processing_time
            
            logger.error(f"‚ùå Error monitoring namespace '{namespace_name}': {e}", exc_info=True)
            
            # Store error result
            namespace_results.append({
                'namespace': namespace_name,
                'metrics': None,
                'processing_time': namespace_processing_time,
                'status': 'error',
                'error': str(e)
            })
            
            # Log error summary for this namespace
            error_summary = {
                "eventType": "NamespaceMonitoringError",
                "timestamp": datetime.utcnow().isoformat(),
                "namespace": namespace_name,
                "processingTimeSeconds": namespace_processing_time,
                "error": str(e),
                "configuration": {
                    "hasConnectionString": bool(config['connection_string']),
                    "hasSubscriptionId": bool(config['subscription_id']),
                    "hasResourceGroup": bool(config['resource_group']),
                    "hasStorageConnection": bool(config['storage_connection_string'])
                }
            }
            
            import json
            logger.error(f"Namespace Monitoring Error Summary: {json.dumps(error_summary)}")
    
    # Log final summary across all namespaces
    log_final_summary(logger, namespace_results, total_processing_time, total_eventhubs, total_partitions, total_consumer_groups)


def log_monitoring_results(logger: logging.Logger, 
                         monitor_logger: ComprehensiveMonitorLogger,
                         namespace_metrics, 
                         processing_time: float):
    """Log comprehensive monitoring results with rich structured data"""
    
    # 1. Log namespace overview with structured data
    logger.info("üìä NAMESPACE MONITORING RESULTS")
    logger.info("=" * 50)
    logger.info(f"Namespace: {namespace_metrics.namespace}")
    logger.info(f"Discovery Method: {namespace_metrics.discovery_method}")
    logger.info(f"Processing Time: {processing_time:.2f} seconds")
    logger.info(f"EventHubs Discovered: {namespace_metrics.total_eventhubs}")
    logger.info(f"Total Partitions: {namespace_metrics.total_partitions}")
    logger.info(f"Total Consumer Groups: {namespace_metrics.total_consumer_groups}")
    
    # Log structured namespace metrics
    monitor_logger.log_namespace_metrics(namespace_metrics)
    
    # 2. Log summary for each EventHub
    for eh_metrics in namespace_metrics.eventhubs:
        logger.info(f"\nüéØ EventHub: {eh_metrics.hub_name}")
        logger.info(f"  Partitions: {eh_metrics.partition_count}")
        logger.info(f"  Consumer Groups: {eh_metrics.total_consumer_groups}")
        logger.info(f"  Active Consumer Groups: {eh_metrics.active_consumer_groups}")
        logger.info(f"  Status: {eh_metrics.status}")
        
        # Log structured EventHub metrics
        monitor_logger.log_eventhub_metrics(eh_metrics)
        
        # 3. Log consumer group health summary
        for cg_metrics in eh_metrics.consumer_groups:
            health_status = get_health_status(cg_metrics.activity_score)
            logger.info(f"    üë• Consumer Group '{cg_metrics.consumer_group}': {health_status}")
            logger.info(f"       Activity Score: {cg_metrics.activity_score:.1f}%")
            logger.info(f"       Total Messages Available: {cg_metrics.total_available_messages}")
            logger.info(f"       Active Partitions: {cg_metrics.active_partitions}/{cg_metrics.total_partitions}")
            
            if cg_metrics.partitions_with_errors > 0:
                logger.warning(f"       ‚ö†Ô∏è  {cg_metrics.partitions_with_errors} partitions have errors")
            if cg_metrics.empty_partitions > 0:
                logger.warning(f"       ‚ö†Ô∏è  {cg_metrics.empty_partitions} partitions are empty")
            
            # Log detailed consumer group metrics
            monitor_logger.log_consumer_group_activity(cg_metrics)
    
    # 4. Log overall health summary
    total_cgs = namespace_metrics.total_consumer_groups
    active_cgs = sum(eh.active_consumer_groups for eh in namespace_metrics.eventhubs)
    
    if total_cgs > 0:
        overall_activity = (active_cgs / total_cgs) * 100
        health_status = get_health_status(overall_activity)
        logger.info(f"\nüè• OVERALL HEALTH: {health_status}")
        logger.info(f"   {active_cgs}/{total_cgs} consumer groups active ({overall_activity:.1f}%)")
    
    # 5. Log monitoring summary
    monitor_logger.log_monitoring_summary(processing_time, namespace_metrics)
    
    # 6. Log alerts for unhealthy consumer groups
    log_health_alerts(logger, namespace_metrics)


def get_health_status(health_score: float) -> str:
    """Get health status with emoji based on health score"""
    if health_score >= 90:
        return f"‚úÖ HEALTHY ({health_score:.1f}%)"
    elif health_score >= 70:
        return f"‚ö†Ô∏è  WARNING ({health_score:.1f}%)"
    else:
        return f"‚ùå CRITICAL ({health_score:.1f}%)"


def log_health_alerts(logger: logging.Logger, namespace_metrics):
    """Log alerts for consumer groups with health issues"""
    alerts = []
    
    for eh_metrics in namespace_metrics.eventhubs:
        for cg_metrics in eh_metrics.consumer_groups:
            if cg_metrics.activity_score < 70:  # Critical threshold
                alerts.append({
                    "severity": "CRITICAL" if cg_metrics.activity_score < 50 else "WARNING",
                    "eventhub": eh_metrics.hub_name,
                    "consumerGroup": cg_metrics.consumer_group,
                    "activityScore": cg_metrics.activity_score,
                    "totalAvailableMessages": cg_metrics.total_available_messages,
                    "partitionsWithErrors": cg_metrics.partitions_with_errors,
                    "emptyPartitions": cg_metrics.empty_partitions
                })
    
    if alerts:
        logger.warning(f"üö® HEALTH ALERTS: {len(alerts)} consumer groups need attention")
        
        for alert in alerts:
            severity_emoji = "üî¥" if alert["severity"] == "CRITICAL" else "‚ö†Ô∏è"
            logger.warning(f"{severity_emoji} {alert['severity']}: "
                         f"EventHub '{alert['eventhub']}', "
                         f"Consumer Group '{alert['consumerGroup']}' - "
                         f"Activity: {alert['activityScore']:.1f}%, "
                         f"Available Messages: {alert['totalAvailableMessages']}")
        
        # Log structured alert data
        import json
        alert_log = {
            "eventType": "HealthAlerts",
            "timestamp": datetime.utcnow().isoformat(),
            "namespace": namespace_metrics.namespace,
            "alertCount": len(alerts),
            "alerts": alerts
        }
        logger.warning(f"Health Alerts: {json.dumps(alert_log)}")
    else:
        logger.info("‚úÖ No health alerts - all consumer groups are healthy!")


if __name__ == "__main__":
    """For local testing purposes"""
    class TimerRequest:
        """Mock TimerRequest for local testing"""
        def __init__(self, past_due=False):
            self.past_due = past_due
    
    # Configure logging
    configure_logging()
    
    # Run main function with mock timer
    main(TimerRequest())
